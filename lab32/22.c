/*   [Златопольский,2007,с.237]
     Поле шахматной доски определяется парой натуральных чисел,  каж-
  дое из которых не превосходит восьми: первое число - номер вертика-
  ли (нумерация осуществляется слева направо),  второе - номер  гори-
  зонтали (нумерация осуществляется снизу вверх). Значениями перемен-
  ных  a, b, c, d, e и f являются случайные натуральные числа, каждое
  из которых не превосходит восьми.
     Пусть на поле (a,b) расположена белая фигура,  на поле  (c,d)  -
  черная.
     Составьте программу,  определяющую может ли белая фигура перейти
  на поле (e,f), не попав при этом под удар чёрной фигуры.
     Рассмотрите следующие варианты сочетаний белой и чёрной фигур:
 
   (1) ладья и ладья;   (8) ферзь и слон;    (15) слон и конь;
   (2) ладья и ферзь;   (9) конь и конь;     (16) слон и ладья;
   (3) ладья и конь;    (10) конь и ладья;   (17) король и слон;
   (4) ладья и слон;    (11) конь и ферзь;   (18) король и ферзь;
   (5) ферзь и ферзь;   (12) конь и слон;    (19) король и конь;
   (6) ферзь и ладья;   (13) слон и слон;    (20) король и ладья.
   (7) ферзь и конь;    (14) слон и ферзь;  */


 #include<stdio.h>
 #include<conio.h>
 #include<stdlib.h>
 #include<time.h>
 #define A 1
 #define B 8

 int rook(int, int, int, int);
 int bishop(int, int, int, int);
 int king(int, int, int, int);
 int queen(int, int, int, int);
 int knight(int, int, int, int);
 int main()
 {
     system("chcp 1251");
     system("cls");
     unsigned int a,b,c,d,e,f,n=1;
     printf("\n");
     printf("(1) ладья и ладья;   (8) ферзь и слон;    (15) слон и конь;\n");
     printf("(2) ладья и ферзь;   (9) конь и конь;     (16) слон и ладья;\n");
     printf("(3) ладья и конь;    (10) конь и ладья;   (17) король и слон;\n");
     printf("(4) ладья и слон;    (11) конь и ферзь;   (18) король и ферзь;\n");
     printf("(5) ферзь и ферзь;   (12) конь и слон;    (19) король и конь;\n");
     printf("(6) ферзь и ладья;   (13) слон и слон;    (20) король и ладья;\n");
     printf("(7) ферзь и конь;    (14) слон и ферзь;    (0) ВЫХОД.\n");
     srand(time(NULL));
     while(n)
     {
        printf("\n");
        printf("Введите номер ситуации: "); scanf("%d",&n); printf("\n");
        a=A+rand()%B;
        b=A+rand()%B;
        c=A+rand()%B;
        d=A+rand()%B;
        e=A+rand()%B;
        f=A+rand()%B;
        if (n) printf("Белая фигура (%d,%d), Черная фигура(%d,%d), Поле(%d,%d)\n",a,b,c,d,e,f);
        switch(n)
        {
            case 1:
                if(rook(a,b,e,f)&&rook(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 2:
                if(rook(a,b,e,f)&&queen(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 3:
                if(rook(a,b,e,f)&&knight(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 4:
                if(rook(a,b,e,f)&&bishop(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 5:
                if(queen(a,b,e,f)&&queen(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 6:
                if(queen(a,b,e,f)&&rook(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 7:
                if(queen(a,b,e,f)&&knight(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 8:
                if(queen(a,b,e,f)&&bishop(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 9:
                if(knight(a,b,e,f)&&knight(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 10:
                if(knight(a,b,e,f)&&rook(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 11:
                if(knight(a,b,e,f)&&queen(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 12:
                if(knight(a,b,e,f)&&bishop(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 13:
                if(bishop(a,b,e,f)&&bishop(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 14:
                if(bishop(a,b,e,f)&&queen(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 15:
                if(bishop(a,b,e,f)&&knight(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 16:
                if(bishop(a,b,e,f)&&rook(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 17:
                if(king(a,b,e,f)&&bishop(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 18:
                if(king(a,b,e,f)&&queen(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 19:
                if(king(a,b,e,f)&&knight(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            case 20:
                if(king(a,b,e,f)&&rook(c,d,e,f))
                printf("Белая фигура сможет перейти в поле (e,f), не попав под удар черной\n");
                else printf("Белой фигуре будет угрожать черная в поле (e,f)\n");
                break;
            default: printf(">_>");
        }
     }
     getch();
     return 0;
}

int rook(int xr, int yr, int x, int y)
{
  return ((xr==x)||(yr==y))?0:1;
}

int bishop(int xb, int yb, int x1,int y1)
{
   return ((xb+yb)==(x1+y1))||(abs(xb-yb)==abs(x1-y1))?0:1;
}

int king(int xk, int yk, int x2, int y2)
{
   return ((abs(xk-x2)==1)||(abs(yk-y2)==1))?0:1;
}

int queen(int xq, int yq, int x3, int y3)
{
   return (((xq==x3)||(yq==y3))||(abs(xq-yq)==abs(x3-y3))||((xq+yq)==(x3+y3)))?0:1;
}

int knight(int xk, int yk, int x4, int y4)
{
  return ((abs(x4-xk)==1)&&(abs(y4-yk)==2))||((abs(x4-xk)==2)&&(abs(y4-yk)==1))?0:1;
}
